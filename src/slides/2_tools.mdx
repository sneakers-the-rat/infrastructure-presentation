import { Heading, Box, Text, Image, Grid } from 'spectacle'
import Paper from '@material-ui/core/Paper'
import CanvasDraw from "react-canvas-draw";
import VerticalLinearStepper from '../components/vertical_stepper'
import ExptRequirements from '../img/task_requirements_2.png'
import Parallax from '../img/plax.png'
import Overview from '../img/overview.svg'
import Analysis1 from '../img/analysis_1-01.svg'
import anime from 'animejs'
import SvgAnimator from '../components/svg_animator';
import {PositionedHeading, Collapser} from '../components/basic';
import {PositionedCard} from '../components/basiccard';


<SvgAnimator
    svgUrl={Overview}
    steps={[
      [
        {targets:'#rect-data',
          fill:["#2f0987", "#333333"],
        easing:"easeInOutQuad",
        duration: 500},
        {targets:"#overview-1 #data *",
          stroke: ["#2f0987", "#333333"],
          easing:"easeInOutQuad"
        },
        {targets:'#rect-tools',
          width:[0,750]},
        {targets:"#overview-1 #tools *",
          strokeDashoffset: [anime.setDashoffset, 0]
        },
        {targets:'#rect-knowledge',
          opacity:[0,0]},
        {targets:"#overview-1 #knowledge *",
          opacity: [0,0]
        }
      ]
    ]}
    id={'overview-1'}
/>


<PositionedHeading id={'overview-knowledge'} y={250} x={20}>Knowledge</PositionedHeading>

<PositionedHeading id={'overview-tools'} y={600} x={20}>Tools</PositionedHeading>

<PositionedHeading id={'overview-data'} y={950} x={20}>Data</PositionedHeading>


---

<SvgAnimator
    svgUrl={Analysis1}
    steps={[
      [
        {targets:'#analysis-1 #scribble>path',
          strokeDashoffset: [anime.setDashoffset, 0],
          duration: 2000,
          delay: 0,
          easing: 'easeInOutCirc'},
        {targets: "#analysis-1 #scribble #analysis *",
        opacity:[0,1],
        duration: 1000,
          delay: 1000,
          easing: 'easeInOutQuad'
        },
        {targets:'#analysis-1 #scribble>polygon',
          width: [0, 1],
          duration: 500,
          delay: 0,
          easing: 'easeInOutCirc'}
      ],
        [
      {targets: "#analysis-1 #scribble #analysis *",
        opacity:[1,0],
        duration: 500,
        easing: 'easeInOutQuad'
      },
          {targets:'#analysis-1 #scribble>path',
          strokeDashoffset: [0, anime.setDashoffset],
          duration: 500,
          delay: 0,
          easing: 'easeInOutCirc'},
      {targets:'#analysis-1 #modules *',
        strokeDashoffset: {
          value:[anime.setDashoffset, 0],
          duration: anime.random(500,1000),
          delay: anime.random(500,1500),
          easing: 'easeInOutCirc'
        },
        opacity: {
          value: [0, 1],
          delay:500,
          duration: 500,
          easing: 'easeInOutQuad'
        }
        },
          {targets:'#analysis-1 #module *',
            strokeDashoffset: {
              value:[anime.setDashoffset, 0],
              duration: anime.random(500,1000),
              delay: anime.random(500,1500),
              easing: 'easeInOutCirc'
            },
            opacity: {
              value: [0, 1],
              delay:500,
              duration: 500,
              easing: 'easeInOutQuad'
            }},
          {
            targets: "#analysis-modular-card",
            opacity: [0,1],
            easing: 'easeInOutQuad',
            duration:500
          }
            ],
        [
            {targets:'#analysis-1 #params *',
          strokeDashoffset: {
            value:[anime.setDashoffset, 0],
            duration: anime.random(500,1000),
            delay: anime.random(500,1500),
            easing: 'easeInOutCirc'
          },
          opacity: {
            value: [0, 1],
            delay:500,
            duration: 500,
            easing: 'easeInOutQuad'
          }
        },
          {targets: "#analysis-1 #module",
          scale:[1,1.5],
          duration:500,
          delay: 500}],
      [
        {targets:'#analysis-1 #tools *',
          strokeDashoffset: {
            value:[anime.setDashoffset, 0],
            duration: anime.random(500,1000),
            delay: anime.random(500,1500),
            easing: 'easeInOutCirc'
          },
          opacity: {
            value: [0, 1],
            delay:500,
            duration: 500,
            easing: 'easeInOutQuad'
          }
        }],
      [
        {targets:'#analysis-1 #container *',
          strokeDashoffset: {
            value:[anime.setDashoffset, 0],
            duration: anime.random(500,1000),
            delay: anime.random(500,1500),
            easing: 'easeInOutCirc'
          },
          opacity: {
            value: [0, 1],
            delay:500,
            duration: 500,
            easing: 'easeInOutQuad'
          }
        },
        {targets: "#analysis-1 #module",
          scale:[1.5, 1],
          duration:500,
          delay: 0}]
    ]}
    id={'analysis-1'}
/>


<PositionedCard
    id={'analysis-modular-card'} x={400} y={725} width={1/4}
    title={"Modular"}
    extraClass={'noshadow'}
    opacity={1}
    body={"Break analyses into input, processing, and output nodes"}
    appearStep={2}
/>




Notes: Overlay datajoint elements & bids apps are good starts!

---

# Federated P2P & Modular Analysis

* Replicability -- having a clearly reproducible analysis pipline is good
  in itself, but when the data sharing system is also designed
  such that someone doesn't need to set up a whole ass database,
  figure out how to get queries, it's even more dope.
* Inspectability - "never roll yr own crypto" but ppl roll their own
  analysis all day long. examples of bugs
* Scientific Consensus - giving a language to ongoing comparisons and
  debates in the field literally in their implementation allows
  us to more plainly see the diversity of opinion and results --
  what if you could apply an analysis method to an entire body of
  previously collected data? or two? This could decouple a paper from its analysis
* A Global F@H - At the point when everyone is connected
  and volunteering a million tiny servers, it would be possible to
  build a global folding@home with idle computing time datajoint
  elements says as much in their paper (screenshot)


---

# Experimental Framework

What kind of tool do we need for the next 10 years of neuroscience?

* **Flexible** enough to handle infinitely variable naturalistic tasks
* **Fast** enough for realtime control and huge data
* **Accessible** enough for anyone to use and contribute to
* **Reproducible** enough to support replication and provenance

(Autopilot logo) here's an example from autopilot

---

checkboxes to tick off elements of experiment
- cameras: control any hardware, any amount bc distributed
- dlc: integrate with external libraries
- computers: flexible task design


<Image src={Parallax} maxWidth={"100%"} maxHeight={"100%"}></Image>

---

# Integrate with custom components

- platform: control esoteric hardware with easy controls like platform.height = 100

<div style={{zIndex: -1}}>
  <iframe loading={"lazy"}
          src="https://player.vimeo.com/video/543747956?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479"
          frameBorder="0" allow="autoplay; fullscreen; picture-in-picture" allowFullScreen
          style={{position: "absolute", top: 0, left: 0, width: "100%", height: "100%"}} title="hell_naw.mp4"></iframe>
</div><script src="https://player.vimeo.com/api/player.js"></script>

---

# focus on imu

figure to break down different parts of what goes into IMU

u can use any part of the system by itself


---

# Closing section

return to diagram, draw in combinatoric benefits

Notes: tools notes

# Combinatoric Benefits

* completely obviate the need for conversion
* Complete replication becomes possible -- circular provenance
* Making analytical tools

# Other projects

* Bonsai - good! we love it!
* BEADL - interesting! statecharts are cool! it's a big ask to
get everyone to fundamentally change how they express and
do their experiments, instead we should focus on the tool side
of thing rather than the standardization and formalization side
of things!!

# Again a design practice, not a product

We need to make our programs easier to interface with one another --
provide clearer inputs and outputs, points where other programs
can pull and push information to our programs.

BEADL this is a fundamentally diffrent approach to standardization
what if we made it unnecessary to standardize terminology and task definitions
by allowing people to express their task in their terms but in a
system where their contribution ould be integrated with others?

What's missing:

Community structure


---


